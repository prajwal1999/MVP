// matrix order.
$parameter MATRIX_ORDER 	32

// storage for the matrix A
// stores xth column st. {x mod 2 == 0 }  
$storage A_0: $array [MATRIX_ORDER][{MATRIX_ORDER/2}] $of $uint<32>
// stores xth column st. {x mod 2 == 1 }  
$storage A_1: $array [MATRIX_ORDER][{MATRIX_ORDER/2}] $of $uint<32>

// storage for input vector x
// stores ith value st. {i mod 2 == 0 }
$storage x_0: $array [{MATRIX_ORDER/2}] $of $uint<32>
// stores ith value st. {i mod 2 == 1 }
$storage x_1: $array [{MATRIX_ORDER/2}] $of $uint<32>

// storage for output vector y.
$storage y: $array [MATRIX_ORDER] $of $uint<32>

// in-data pipe
$pipe in_data: $uint<32> $depth 2

// out-data pipe
$pipe out_data: $uint<32> $depth 2

// helper module for reading the matrix and  populating the A array.
$module [readMatrix] $in () $out () $is
{
	$branchblock[mRead] {

		$merge $entry outer_loopback
			$phi I := ($bitcast ($uint<8>) 0) $on $entry nI $on outer_loopback
		$endmerge


			nI := (I + 1) 
			$merge $entry inner_loopback
				$phi J := ($bitcast ($uint<8>) 0) $on $entry nJ $on inner_loopback
			$endmerge 
			nJ := (J + 1)

			$volatile odd_idx := (J [] 0)
			Jr := ($slice J 7 1)

			aval := in_data
			$guard (odd_idx) A_1[I][Jr] := aval
			$guard (odd_idx)
				$rreport (readMatrix_odd  odd_idx I J Jr aval)

			$guard (~odd_idx) A_0[I][Jr] := aval
			$guard (~odd_idx)
				$rreport (readMatrix_even  even_idx I J Jr aval)


			$if (nJ < MATRIX_ORDER) $then
				$place [inner_loopback]
			$endif
				
		$if (nI < MATRIX_ORDER) $then
				$place [outer_loopback]
		$endif
	}
}

// helper module which reads the vector x.
$module [readVector] $in () $out () $is
{
	$branchblock [loop] {
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi I := ($bitcast ($uint<8>) 0) $on $entry nI $on $loopback
			$endmerge 

			$volatile odd_idx := (I [] 0)
			$volatile I_idx := ($slice I 7 1)

			temp_val := in_data
			$guard (odd_idx) x_1[I_idx] := temp_val
			$guard (~odd_idx) x_0[I_idx] := temp_val

			$volatile nI := (I + 1)
		$while (nI < MATRIX_ORDER)
	}
}

// helper module which sends the calculated value of y to the external world.
$module [sendVector] $in () $out () $is
{
	$branchblock [loop] {
		$dopipeline $depth 7 $fullrate
			$merge $entry $loopback
				$phi I := ($bitcast ($uint<8>) 0) $on $entry nI $on $loopback
			$endmerge 
			out_data := y[I]
			$volatile nI := (I + 1)
		$while (nI < MATRIX_ORDER)
	}
}

// dot product of the R'th row of A with the vector x. This gives the R'th element of Y.
$module [dotP_even] $in (R: $uint<8>) $out (result: $uint<32>) $is
{
	$branchblock[mmloop] {
		$dopipeline $depth 15 $fullrate
			$merge $entry $loopback 
				$phi C := ($bitcast ($uint<8>) 0) $on $entry nC $on $loopback
				$phi val_even := ($bitcast ($uint<32>) 0) $on $entry nval_even $on $loopback
				$phi val_odd := ($bitcast ($uint<32>) 0) $on $entry nval_odd $on $loopback
			$endmerge

			$volatile Cr := ($slice C 7 1)

			// Pipelined memory reads
			a_rc_even := A_0[R][Cr]
			a_rc_odd := A_1[R][Cr]

			xval_even := x_0[Cr]
			xval_odd := x_1[Cr]

			$volatile nval_even := (val_even + (a_rc_even * xval_even))
			$rreport (dotP_even even val_even a_rc_even xval_even nval_even)

			$volatile nval_odd := (val_odd + (a_rc_odd * xval_odd))
			$rreport (dotP_even odd val_odd a_rc_odd xval_odd nval_odd)


			nC := (C + 2)

		$while (nC < MATRIX_ORDER)
	} (nval_even => nval_even nval_odd => nval_odd)
	result := (nval_even + nval_odd)
}

$module [dotP_odd] $in (R: $uint<8>) $out (result: $uint<32>) $is
{
	$branchblock[mmloop] {
		$dopipeline $depth 15 $fullrate
			$merge $entry $loopback 
				$phi C := ($bitcast ($uint<8>) 0) $on $entry nC $on $loopback
				$phi val_even := ($bitcast ($uint<32>) 0) $on $entry nval_even $on $loopback
				$phi val_odd := ($bitcast ($uint<32>) 0) $on $entry nval_odd $on $loopback
			$endmerge

			$volatile Cr := ($slice C 7 1)

			// Pipelined memory reads
			a_rc_even := A_0[R][Cr]
			a_rc_odd := A_1[R][Cr]

			xval_even := x_0[Cr]
			xval_odd := x_1[Cr]

			$volatile nval_even := (val_even + (a_rc_even * xval_even))
			$rreport (dotP_odd even val_even a_rc_even xval_even nval_even)

			$volatile nval_odd := (val_odd + (a_rc_odd * xval_odd))
			$rreport (dotP_odd odd val_odd a_rc_odd xval_odd nval_odd)


			nC := (C + 2)

		$while (nC < MATRIX_ORDER)
	} (nval_even => nval_even nval_odd => nval_odd)
	result := (nval_even + nval_odd)
}


// main module which performs A.x = y. assumes that A, x are available.
$module [multiplyMatrixVector] $in () $out () $is
{
	// dot product loop
	$branchblock[mmloop] {
		$merge $entry loopback 
			$phi R := ($bitcast ($uint<8>) 0) $on $entry nR $on loopback
		$endmerge

			$call dotP_even (R) (val_even)
			$call dotP_odd ((R+1)) (val_odd)

			y[R] := val_even
			y[(R+1)] := val_odd

			nR := (R + 1)
		$if (nR < MATRIX_ORDER) $then
			$place [loopback]
		$endif

	}
}

// main thread: reads the matrix, and works on vectors..
$module [mvp_daemon] $in () $out () $is
{
	// read the matrix.
	$call readMatrix () ()

	$branchblock [loop] {

		$merge $entry loopback $endmerge

		$call readVector () ()
		$call multiplyMatrixVector () ()
		$call sendVector () ()

		$place [loopback]
	}
}

